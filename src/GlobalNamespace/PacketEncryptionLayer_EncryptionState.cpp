// Autogenerated from CppSourceCreator
// Created by Sc2ad
// =========================================================================
// Begin includes
#include "extern/beatsaber-hook/shared/utils/typedefs.h"
// Including type: PacketEncryptionLayer/EncryptionState
#include "GlobalNamespace/PacketEncryptionLayer_EncryptionState.hpp"
// Including type: System.Security.Cryptography.HMAC
#include "System/Security/Cryptography/HMAC.hpp"
#include "extern/beatsaber-hook/shared/utils/il2cpp-utils.hpp"
#include "extern/beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Autogenerated method: PacketEncryptionLayer/EncryptionState.Verify
bool GlobalNamespace::PacketEncryptionLayer::EncryptionState::Verify(uint protocolVersion, ::Il2CppString* userId, ::Il2CppString* userName) {
  return THROW_UNLESS(il2cpp_utils::RunMethod<bool>(this, "Verify", protocolVersion, userId, userName));
}
// Autogenerated method: PacketEncryptionLayer/EncryptionState.HasTimedOut
bool GlobalNamespace::PacketEncryptionLayer::EncryptionState::HasTimedOut(int64_t timeout) {
  return THROW_UNLESS(il2cpp_utils::RunMethod<bool>(this, "HasTimedOut", timeout));
}
// Autogenerated method: PacketEncryptionLayer/EncryptionState.IsValidSequenceNum
bool GlobalNamespace::PacketEncryptionLayer::EncryptionState::IsValidSequenceNum(uint sequenceNum) {
  return THROW_UNLESS(il2cpp_utils::RunMethod<bool>(this, "IsValidSequenceNum", sequenceNum));
}
// Autogenerated method: PacketEncryptionLayer/EncryptionState.PutSequenceNum
bool GlobalNamespace::PacketEncryptionLayer::EncryptionState::PutSequenceNum(uint sequenceNum) {
  return THROW_UNLESS(il2cpp_utils::RunMethod<bool>(this, "PutSequenceNum", sequenceNum));
}
// Autogenerated method: PacketEncryptionLayer/EncryptionState.GetNextSentSequenceNum
uint GlobalNamespace::PacketEncryptionLayer::EncryptionState::GetNextSentSequenceNum() {
  return THROW_UNLESS(il2cpp_utils::RunMethod<uint>(this, "GetNextSentSequenceNum"));
}
// Autogenerated method: PacketEncryptionLayer/EncryptionState..ctor
GlobalNamespace::PacketEncryptionLayer::EncryptionState* GlobalNamespace::PacketEncryptionLayer::EncryptionState::New_ctor(uint protocolVersion, ::Array<uint8_t>* preMasterSecret, ::Array<uint8_t>* serverSeed, ::Array<uint8_t>* clientSeed, bool isClient) {
  return THROW_UNLESS(il2cpp_utils::New<PacketEncryptionLayer::EncryptionState*>(protocolVersion, preMasterSecret, serverSeed, clientSeed, isClient));
}
// Autogenerated method: PacketEncryptionLayer/EncryptionState.MakeSeed
::Array<uint8_t>* GlobalNamespace::PacketEncryptionLayer::EncryptionState::MakeSeed(::Array<uint8_t>* baseSeed, ::Array<uint8_t>* serverSeed, ::Array<uint8_t>* clientSeed) {
  return THROW_UNLESS(il2cpp_utils::RunMethod<::Array<uint8_t>*>(this, "MakeSeed", baseSeed, serverSeed, clientSeed));
}
// Autogenerated method: PacketEncryptionLayer/EncryptionState.PRF
::Array<uint8_t>* GlobalNamespace::PacketEncryptionLayer::EncryptionState::PRF(::Array<uint8_t>* key, ::Array<uint8_t>* seed, int length) {
  return THROW_UNLESS(il2cpp_utils::RunMethod<::Array<uint8_t>*>("", "PacketEncryptionLayer/EncryptionState", "PRF", key, seed, length));
}
// Autogenerated method: PacketEncryptionLayer/EncryptionState.PRF_Hash
void GlobalNamespace::PacketEncryptionLayer::EncryptionState::PRF_Hash(::Array<uint8_t>* key, ::Array<uint8_t>* seed, int& length) {
  THROW_UNLESS(il2cpp_utils::RunMethod("", "PacketEncryptionLayer/EncryptionState", "PRF_Hash", key, seed, length));
}
// Autogenerated method: PacketEncryptionLayer/EncryptionState.SetIdentity
bool GlobalNamespace::PacketEncryptionLayer::EncryptionState::SetIdentity(::Il2CppString* userId, ::Il2CppString* userNmae) {
  return THROW_UNLESS(il2cpp_utils::RunMethod<bool>(this, "SetIdentity", userId, userNmae));
}
// Autogenerated method: PacketEncryptionLayer/EncryptionState.Dispose
void GlobalNamespace::PacketEncryptionLayer::EncryptionState::Dispose() {
  THROW_UNLESS(il2cpp_utils::RunMethod(this, "Dispose"));
}
void GlobalNamespace::PacketEncryptionLayer::EncryptionState::System_IDisposable_Dispose() {
  GlobalNamespace::PacketEncryptionLayer::EncryptionState::Dispose();
}
