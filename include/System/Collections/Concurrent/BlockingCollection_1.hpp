// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
#pragma pack(push, 8)
// Begin includes
#include "extern/beatsaber-hook/shared/utils/typedefs.h"
// Including type: System.Collections.ICollection
#include "System/Collections/ICollection.hpp"
// Including type: System.IDisposable
#include "System/IDisposable.hpp"
// Including type: System.Collections.Generic.IReadOnlyCollection`1
#include "System/Collections/Generic/IReadOnlyCollection_1.hpp"
// Including type: System.Threading.CancellationToken
#include "System/Threading/CancellationToken.hpp"
#include "extern/beatsaber-hook/shared/utils/il2cpp-utils.hpp"
#include "extern/beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: System::Collections::Concurrent
namespace System::Collections::Concurrent {
  // Forward declaring type: IProducerConsumerCollection`1<T>
  template<typename T>
  class IProducerConsumerCollection_1;
}
// Forward declaring namespace: System::Threading
namespace System::Threading {
  // Forward declaring type: SemaphoreSlim
  class SemaphoreSlim;
  // Forward declaring type: CancellationTokenSource
  class CancellationTokenSource;
}
// Forward declaring namespace: System
namespace System {
  // Forward declaring type: Array
  class Array;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: IEnumerator`1<T>
  template<typename T>
  class IEnumerator_1;
}
// Forward declaring namespace: System::Collections
namespace System::Collections {
  // Forward declaring type: IEnumerator
  class IEnumerator;
}
// Completed forward declares
// Type namespace: System.Collections.Concurrent
namespace System::Collections::Concurrent {
  // Autogenerated type: System.Collections.Concurrent.BlockingCollection`1
  template<typename T>
  class BlockingCollection_1 : public ::Il2CppObject/*, public System::Collections::ICollection, public System::IDisposable, public System::Collections::Generic::IReadOnlyCollection_1<T>*/ {
    public:
    // private System.Collections.Concurrent.IProducerConsumerCollection`1<T> _collection
    // Offset: 0x0
    System::Collections::Concurrent::IProducerConsumerCollection_1<T>* collection;
    // private System.Int32 _boundedCapacity
    // Offset: 0x0
    int boundedCapacity;
    // private System.Threading.SemaphoreSlim _freeNodes
    // Offset: 0x0
    System::Threading::SemaphoreSlim* freeNodes;
    // private System.Threading.SemaphoreSlim _occupiedNodes
    // Offset: 0x0
    System::Threading::SemaphoreSlim* occupiedNodes;
    // private System.Boolean _isDisposed
    // Offset: 0x0
    bool isDisposed;
    // private System.Threading.CancellationTokenSource _consumersCancellationTokenSource
    // Offset: 0x0
    System::Threading::CancellationTokenSource* consumersCancellationTokenSource;
    // private System.Threading.CancellationTokenSource _producersCancellationTokenSource
    // Offset: 0x0
    System::Threading::CancellationTokenSource* producersCancellationTokenSource;
    // private System.Int32 _currentAdders
    // Offset: 0x0
    int currentAdders;
    // Creating interface conversion operator: operator System::Collections::ICollection
    operator System::Collections::ICollection() noexcept {
      return *reinterpret_cast<System::Collections::ICollection*>(this);
    }
    // Creating interface conversion operator: operator System::IDisposable
    operator System::IDisposable() noexcept {
      return *reinterpret_cast<System::IDisposable*>(this);
    }
    // Creating interface conversion operator: operator System::Collections::Generic::IReadOnlyCollection_1<T>
    operator System::Collections::Generic::IReadOnlyCollection_1<T>() noexcept {
      return *reinterpret_cast<System::Collections::Generic::IReadOnlyCollection_1<T>*>(this);
    }
    // public System.Boolean get_IsAddingCompleted()
    // Offset: 0xFFFFFFFF
    bool get_IsAddingCompleted() {
      return THROW_UNLESS(il2cpp_utils::RunMethod<bool>(this, "get_IsAddingCompleted"));
    }
    // public System.Boolean get_IsCompleted()
    // Offset: 0xFFFFFFFF
    bool get_IsCompleted() {
      return THROW_UNLESS(il2cpp_utils::RunMethod<bool>(this, "get_IsCompleted"));
    }
    // public System.Void .ctor(System.Collections.Concurrent.IProducerConsumerCollection`1<T> collection)
    // Offset: 0xFFFFFFFF
    static BlockingCollection_1<T>* New_ctor(System::Collections::Concurrent::IProducerConsumerCollection_1<T>* collection) {
      return THROW_UNLESS(il2cpp_utils::New<BlockingCollection_1<T>*>(collection));
    }
    // private System.Void Initialize(System.Collections.Concurrent.IProducerConsumerCollection`1<T> collection, System.Int32 boundedCapacity, System.Int32 collectionCount)
    // Offset: 0xFFFFFFFF
    void Initialize(System::Collections::Concurrent::IProducerConsumerCollection_1<T>* collection, int boundedCapacity, int collectionCount) {
      THROW_UNLESS(il2cpp_utils::RunMethod(this, "Initialize", collection, boundedCapacity, collectionCount));
    }
    // public System.Void Add(T item)
    // Offset: 0xFFFFFFFF
    void Add(T item) {
      THROW_UNLESS(il2cpp_utils::RunMethod(this, "Add", item));
    }
    // private System.Boolean TryAddWithNoTimeValidation(T item, System.Int32 millisecondsTimeout, System.Threading.CancellationToken cancellationToken)
    // Offset: 0xFFFFFFFF
    bool TryAddWithNoTimeValidation(T item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken) {
      return THROW_UNLESS(il2cpp_utils::RunMethod<bool>(this, "TryAddWithNoTimeValidation", item, millisecondsTimeout, cancellationToken));
    }
    // public T Take()
    // Offset: 0xFFFFFFFF
    T Take() {
      return THROW_UNLESS(il2cpp_utils::RunMethod<T>(this, "Take"));
    }
    // public System.Boolean TryTake(out T item, System.Int32 millisecondsTimeout, System.Threading.CancellationToken cancellationToken)
    // Offset: 0xFFFFFFFF
    bool TryTake(T& item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken) {
      return THROW_UNLESS(il2cpp_utils::RunMethod<bool>(this, "TryTake", item, millisecondsTimeout, cancellationToken));
    }
    // private System.Boolean TryTakeWithNoTimeValidation(out T item, System.Int32 millisecondsTimeout, System.Threading.CancellationToken cancellationToken, System.Threading.CancellationTokenSource combinedTokenSource)
    // Offset: 0xFFFFFFFF
    bool TryTakeWithNoTimeValidation(T& item, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken, System::Threading::CancellationTokenSource* combinedTokenSource) {
      return THROW_UNLESS(il2cpp_utils::RunMethod<bool>(this, "TryTakeWithNoTimeValidation", item, millisecondsTimeout, cancellationToken, combinedTokenSource));
    }
    // private System.Void CancelWaitingConsumers()
    // Offset: 0xFFFFFFFF
    void CancelWaitingConsumers() {
      THROW_UNLESS(il2cpp_utils::RunMethod(this, "CancelWaitingConsumers"));
    }
    // protected System.Void Dispose(System.Boolean disposing)
    // Offset: 0xFFFFFFFF
    void Dispose(bool disposing) {
      THROW_UNLESS(il2cpp_utils::RunMethod(this, "Dispose", disposing));
    }
    // static private System.Void ValidateMillisecondsTimeout(System.Int32 millisecondsTimeout)
    // Offset: 0xFFFFFFFF
    static void ValidateMillisecondsTimeout(int millisecondsTimeout) {
      THROW_UNLESS(il2cpp_utils::RunMethod(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<BlockingCollection_1<T>*>::get(), "ValidateMillisecondsTimeout", millisecondsTimeout));
    }
    // private System.Void CheckDisposed()
    // Offset: 0xFFFFFFFF
    void CheckDisposed() {
      THROW_UNLESS(il2cpp_utils::RunMethod(this, "CheckDisposed"));
    }
    // public System.Int32 get_Count()
    // Offset: 0xFFFFFFFF
    // Implemented from: System.Collections.ICollection
    // Base method: System.Int32 ICollection::get_Count()
    // Base method: System.Int32 IReadOnlyCollection_1::get_Count()
    int get_Count() {
      return THROW_UNLESS(il2cpp_utils::RunMethod<int>(this, "get_Count"));
    }
    // Creating proxy method: System_Collections_ICollection_get_Count
    // Maps to method: get_Count
    int System_Collections_ICollection_get_Count() {
      return get_Count();
    }
    // public System.Void .ctor()
    // Offset: 0xFFFFFFFF
    // Implemented from: System.Object
    // Base method: System.Void Object::.ctor()
    static BlockingCollection_1<T>* New_ctor() {
      return THROW_UNLESS(il2cpp_utils::New<BlockingCollection_1<T>*>());
    }
    // public System.Void Dispose()
    // Offset: 0xFFFFFFFF
    // Implemented from: System.IDisposable
    // Base method: System.Void IDisposable::Dispose()
    void Dispose() {
      THROW_UNLESS(il2cpp_utils::RunMethod(this, "Dispose"));
    }
    // Creating proxy method: System_IDisposable_Dispose
    // Maps to method: Dispose
    void System_IDisposable_Dispose() {
      Dispose();
    }
    // private System.Void System.Collections.ICollection.CopyTo(System.Array array, System.Int32 index)
    // Offset: 0xFFFFFFFF
    // Implemented from: System.Collections.ICollection
    // Base method: System.Void ICollection::CopyTo(System.Array array, System.Int32 index)
    void System_Collections_ICollection_CopyTo(System::Array* array, int index) {
      THROW_UNLESS(il2cpp_utils::RunMethod(this, "System.Collections.ICollection.CopyTo", array, index));
    }
    // private System.Collections.Generic.IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator()
    // Offset: 0xFFFFFFFF
    // Implemented from: System.Collections.Generic.IEnumerable`1
    // Base method: System.Collections.Generic.IEnumerator`1<T> IEnumerable_1::GetEnumerator()
    System::Collections::Generic::IEnumerator_1<T>* System_Collections_Generic_IEnumerable_1_GetEnumerator() {
      return THROW_UNLESS((il2cpp_utils::RunMethod<System::Collections::Generic::IEnumerator_1<T>*>(this, "System.Collections.Generic.IEnumerable<T>.GetEnumerator")));
    }
    // private System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
    // Offset: 0xFFFFFFFF
    // Implemented from: System.Collections.IEnumerable
    // Base method: System.Collections.IEnumerator IEnumerable::GetEnumerator()
    System::Collections::IEnumerator* System_Collections_IEnumerable_GetEnumerator() {
      return THROW_UNLESS(il2cpp_utils::RunMethod<System::Collections::IEnumerator*>(this, "System.Collections.IEnumerable.GetEnumerator"));
    }
  }; // System.Collections.Concurrent.BlockingCollection`1
}
DEFINE_IL2CPP_ARG_TYPE_GENERIC_CLASS(System::Collections::Concurrent::BlockingCollection_1, "System.Collections.Concurrent", "BlockingCollection`1");
#pragma pack(pop)
