// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
#pragma pack(push, 8)
// Begin includes
#include "extern/beatsaber-hook/shared/utils/typedefs.h"
// Including type: UnityEngine.Timeline.IntervalTreeNode
#include "UnityEngine/Timeline/IntervalTreeNode.hpp"
// Including type: System.Int32
#include "System/Int32.hpp"
// Including type: System.Int64
#include "System/Int64.hpp"
#include "extern/beatsaber-hook/shared/utils/il2cpp-utils.hpp"
#include "extern/beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine::Timeline
namespace UnityEngine::Timeline {
  // Skipping declaration: Entry because it is already included!
  // Forward declaring type: IInterval
  class IInterval;
}
// Forward declaring namespace: System::Collections::Generic
namespace System::Collections::Generic {
  // Forward declaring type: List`1<T>
  template<typename T>
  class List_1;
}
// Completed forward declares
// Type namespace: UnityEngine.Timeline
namespace UnityEngine::Timeline {
  // Autogenerated type: UnityEngine.Timeline.IntervalTree`1
  template<typename T>
  class IntervalTree_1 : public ::Il2CppObject {
    public:
    // Nested type: UnityEngine::Timeline::IntervalTree_1::Entry<T>
    struct Entry;
    // Autogenerated type: UnityEngine.Timeline.IntervalTree`1/Entry
    struct Entry : public System::ValueType, public ::il2cpp_utils::il2cpp_type_check::NestedType {
      public:
      using declaring_type = IntervalTree_1<T>*;
      static constexpr std::string_view NESTED_NAME = "Entry";
      // public System.Int64 intervalStart
      // Offset: 0x0
      int64_t intervalStart;
      // public System.Int64 intervalEnd
      // Offset: 0x0
      int64_t intervalEnd;
      // public T item
      // Offset: 0x0
      T item;
      // Creating value type constructor for type: Entry
      constexpr Entry(int64_t intervalStart_ = {}, int64_t intervalEnd_ = {}, T item_ = {}) noexcept : intervalStart{intervalStart_}, intervalEnd{intervalEnd_}, item{item_} {}
    }; // UnityEngine.Timeline.IntervalTree`1/Entry
    // Could not write size check! Type: UnityEngine.Timeline.IntervalTree`1/Entry is generic!
    // private readonly System.Collections.Generic.List`1<UnityEngine.Timeline.IntervalTree`1/Entry<T>> m_Entries
    // Offset: 0x0
    System::Collections::Generic::List_1<typename UnityEngine::Timeline::IntervalTree_1<T>::Entry>* m_Entries;
    // private readonly System.Collections.Generic.List`1<UnityEngine.Timeline.IntervalTreeNode> m_Nodes
    // Offset: 0x0
    System::Collections::Generic::List_1<UnityEngine::Timeline::IntervalTreeNode>* m_Nodes;
    // private System.Boolean <dirty>k__BackingField
    // Offset: 0x0
    bool dirty;
    // Autogenerated static field getter
    // Get static field: static private System.Int32 kMinNodeSize
    static int _get_kMinNodeSize() {
      static auto ___internal__logger = Logger::get().WithContext("codegen").WithContext("UnityEngine::Timeline").WithContext("IntervalTree_1").WithContext("_get_kMinNodeSize");
      return THROW_UNLESS(il2cpp_utils::GetFieldValue<int>(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<IntervalTree_1<T>*>::get(), "kMinNodeSize"));
    }
    // Autogenerated static field setter
    // Set static field: static private System.Int32 kMinNodeSize
    static void _set_kMinNodeSize(int value) {
      static auto ___internal__logger = Logger::get().WithContext("codegen").WithContext("UnityEngine::Timeline").WithContext("IntervalTree_1").WithContext("_set_kMinNodeSize");
      THROW_UNLESS(il2cpp_utils::SetFieldValue(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<IntervalTree_1<T>*>::get(), "kMinNodeSize", value));
    }
    // Autogenerated static field getter
    // Get static field: static private System.Int32 kInvalidNode
    static int _get_kInvalidNode() {
      static auto ___internal__logger = Logger::get().WithContext("codegen").WithContext("UnityEngine::Timeline").WithContext("IntervalTree_1").WithContext("_get_kInvalidNode");
      return THROW_UNLESS(il2cpp_utils::GetFieldValue<int>(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<IntervalTree_1<T>*>::get(), "kInvalidNode"));
    }
    // Autogenerated static field setter
    // Set static field: static private System.Int32 kInvalidNode
    static void _set_kInvalidNode(int value) {
      static auto ___internal__logger = Logger::get().WithContext("codegen").WithContext("UnityEngine::Timeline").WithContext("IntervalTree_1").WithContext("_set_kInvalidNode");
      THROW_UNLESS(il2cpp_utils::SetFieldValue(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<IntervalTree_1<T>*>::get(), "kInvalidNode", value));
    }
    // Autogenerated static field getter
    // Get static field: static private System.Int64 kCenterUnknown
    static int64_t _get_kCenterUnknown() {
      static auto ___internal__logger = Logger::get().WithContext("codegen").WithContext("UnityEngine::Timeline").WithContext("IntervalTree_1").WithContext("_get_kCenterUnknown");
      return THROW_UNLESS(il2cpp_utils::GetFieldValue<int64_t>(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<IntervalTree_1<T>*>::get(), "kCenterUnknown"));
    }
    // Autogenerated static field setter
    // Set static field: static private System.Int64 kCenterUnknown
    static void _set_kCenterUnknown(int64_t value) {
      static auto ___internal__logger = Logger::get().WithContext("codegen").WithContext("UnityEngine::Timeline").WithContext("IntervalTree_1").WithContext("_set_kCenterUnknown");
      THROW_UNLESS(il2cpp_utils::SetFieldValue(il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<IntervalTree_1<T>*>::get(), "kCenterUnknown", value));
    }
    // public System.Boolean get_dirty()
    // Offset: 0xFFFFFFFF
    bool get_dirty() {
      static auto ___internal__logger = ::Logger::get().WithContext("codegen").WithContext("UnityEngine::Timeline").WithContext("IntervalTree_1").WithContext("get_dirty");
      static auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::FindMethod(this, il2cpp_utils::NoArgClass<bool>(), "get_dirty", {}, ::il2cpp_utils::ExtractTypes()));
      return ::il2cpp_utils::RunMethodThrow<bool, false>(this, ___internal__method);
    }
    // System.Void set_dirty(System.Boolean value)
    // Offset: 0xFFFFFFFF
    void set_dirty(bool value) {
      static auto ___internal__logger = ::Logger::get().WithContext("codegen").WithContext("UnityEngine::Timeline").WithContext("IntervalTree_1").WithContext("set_dirty");
      static auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::FindMethod(this, il2cpp_utils::NoArgClass<void>(), "set_dirty", {}, ::il2cpp_utils::ExtractTypes(value)));
      ::il2cpp_utils::RunMethodThrow<void, false>(this, ___internal__method, value);
    }
    // public System.Void Add(T item)
    // Offset: 0xFFFFFFFF
    void Add(T item) {
      static auto ___internal__logger = ::Logger::get().WithContext("codegen").WithContext("UnityEngine::Timeline").WithContext("IntervalTree_1").WithContext("Add");
      static auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::FindMethod(this, il2cpp_utils::NoArgClass<void>(), "Add", {}, ::il2cpp_utils::ExtractTypes(item)));
      ::il2cpp_utils::RunMethodThrow<void, false>(this, ___internal__method, item);
    }
    // public System.Void IntersectsWith(System.Int64 value, System.Collections.Generic.List`1<T> results)
    // Offset: 0xFFFFFFFF
    void IntersectsWith(int64_t value, System::Collections::Generic::List_1<T>* results) {
      static auto ___internal__logger = ::Logger::get().WithContext("codegen").WithContext("UnityEngine::Timeline").WithContext("IntervalTree_1").WithContext("IntersectsWith");
      static auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::FindMethod(this, il2cpp_utils::NoArgClass<void>(), "IntersectsWith", {}, ::il2cpp_utils::ExtractTypes(value, results)));
      ::il2cpp_utils::RunMethodThrow<void, false>(this, ___internal__method, value, results);
    }
    // public System.Void IntersectsWithRange(System.Int64 start, System.Int64 end, System.Collections.Generic.List`1<T> results)
    // Offset: 0xFFFFFFFF
    void IntersectsWithRange(int64_t start, int64_t end, System::Collections::Generic::List_1<T>* results) {
      static auto ___internal__logger = ::Logger::get().WithContext("codegen").WithContext("UnityEngine::Timeline").WithContext("IntervalTree_1").WithContext("IntersectsWithRange");
      static auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::FindMethod(this, il2cpp_utils::NoArgClass<void>(), "IntersectsWithRange", {}, ::il2cpp_utils::ExtractTypes(start, end, results)));
      ::il2cpp_utils::RunMethodThrow<void, false>(this, ___internal__method, start, end, results);
    }
    // public System.Void UpdateIntervals()
    // Offset: 0xFFFFFFFF
    void UpdateIntervals() {
      static auto ___internal__logger = ::Logger::get().WithContext("codegen").WithContext("UnityEngine::Timeline").WithContext("IntervalTree_1").WithContext("UpdateIntervals");
      static auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::FindMethod(this, il2cpp_utils::NoArgClass<void>(), "UpdateIntervals", {}, ::il2cpp_utils::ExtractTypes()));
      ::il2cpp_utils::RunMethodThrow<void, false>(this, ___internal__method);
    }
    // private System.Void Query(UnityEngine.Timeline.IntervalTreeNode intervalTreeNode, System.Int64 value, System.Collections.Generic.List`1<T> results)
    // Offset: 0xFFFFFFFF
    void Query(UnityEngine::Timeline::IntervalTreeNode intervalTreeNode, int64_t value, System::Collections::Generic::List_1<T>* results) {
      static auto ___internal__logger = ::Logger::get().WithContext("codegen").WithContext("UnityEngine::Timeline").WithContext("IntervalTree_1").WithContext("Query");
      static auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::FindMethod(this, il2cpp_utils::NoArgClass<void>(), "Query", {}, ::il2cpp_utils::ExtractTypes(intervalTreeNode, value, results)));
      ::il2cpp_utils::RunMethodThrow<void, false>(this, ___internal__method, intervalTreeNode, value, results);
    }
    // private System.Void QueryRange(UnityEngine.Timeline.IntervalTreeNode intervalTreeNode, System.Int64 start, System.Int64 end, System.Collections.Generic.List`1<T> results)
    // Offset: 0xFFFFFFFF
    void QueryRange(UnityEngine::Timeline::IntervalTreeNode intervalTreeNode, int64_t start, int64_t end, System::Collections::Generic::List_1<T>* results) {
      static auto ___internal__logger = ::Logger::get().WithContext("codegen").WithContext("UnityEngine::Timeline").WithContext("IntervalTree_1").WithContext("QueryRange");
      static auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::FindMethod(this, il2cpp_utils::NoArgClass<void>(), "QueryRange", {}, ::il2cpp_utils::ExtractTypes(intervalTreeNode, start, end, results)));
      ::il2cpp_utils::RunMethodThrow<void, false>(this, ___internal__method, intervalTreeNode, start, end, results);
    }
    // private System.Void Rebuild()
    // Offset: 0xFFFFFFFF
    void Rebuild() {
      static auto ___internal__logger = ::Logger::get().WithContext("codegen").WithContext("UnityEngine::Timeline").WithContext("IntervalTree_1").WithContext("Rebuild");
      static auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::FindMethod(this, il2cpp_utils::NoArgClass<void>(), "Rebuild", {}, ::il2cpp_utils::ExtractTypes()));
      ::il2cpp_utils::RunMethodThrow<void, false>(this, ___internal__method);
    }
    // private System.Int32 Rebuild(System.Int32 start, System.Int32 end)
    // Offset: 0xFFFFFFFF
    int Rebuild(int start, int end) {
      static auto ___internal__logger = ::Logger::get().WithContext("codegen").WithContext("UnityEngine::Timeline").WithContext("IntervalTree_1").WithContext("Rebuild");
      static auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::FindMethod(this, il2cpp_utils::NoArgClass<int>(), "Rebuild", {}, ::il2cpp_utils::ExtractTypes(start, end)));
      return ::il2cpp_utils::RunMethodThrow<int, false>(this, ___internal__method, start, end);
    }
    // public System.Void Clear()
    // Offset: 0xFFFFFFFF
    void Clear() {
      static auto ___internal__logger = ::Logger::get().WithContext("codegen").WithContext("UnityEngine::Timeline").WithContext("IntervalTree_1").WithContext("Clear");
      static auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::FindMethod(this, il2cpp_utils::NoArgClass<void>(), "Clear", {}, ::il2cpp_utils::ExtractTypes()));
      ::il2cpp_utils::RunMethodThrow<void, false>(this, ___internal__method);
    }
    // public System.Void .ctor()
    // Offset: 0xFFFFFFFF
    // Implemented from: System.Object
    // Base method: System.Void Object::.ctor()
    static IntervalTree_1<T>* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("codegen").WithContext("UnityEngine::Timeline").WithContext("IntervalTree_1").WithContext(".ctor");
      return THROW_UNLESS(::il2cpp_utils::New<IntervalTree_1<T>*>());
    }
  }; // UnityEngine.Timeline.IntervalTree`1
  // Could not write size check! Type: UnityEngine.Timeline.IntervalTree`1 is generic!
}
DEFINE_IL2CPP_ARG_TYPE_GENERIC_CLASS(UnityEngine::Timeline::IntervalTree_1, "UnityEngine.Timeline", "IntervalTree`1");
#pragma pack(pop)
